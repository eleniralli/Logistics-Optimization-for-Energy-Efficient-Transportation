import random
import math

# αλλαξα την model για να ειναι ανοιχτη διδρομη και την buildmodel για να διαβαζει το σωστο αρχειο
#και την route για να ειναι ανοιχτή διαδρομη


class Model:
    def __init__(self):
        self.allNodes = []
        self.customers = []
        self.matrix = []
        self.capacity = -1
        self.empty_vehicle_weight = -1

    def BuildModel(self, filepath):
        with open(filepath, 'r') as file:
            self.capacity = int(next(file).split(',')[1])  # Read CAPACITY
            self.empty_vehicle_weight = int(next(file).split(',')[1])  # Read EMPTY_VEHICLE_WEIGHT
            next(file)  # Skip 'CUSTOMERS' line
            next(file)  # Skip 'NODES INFO' header
            next(file)  # Skip 'ID,XCOORD,YCOORD,DEMAND' header

            for line in file:
                parts = line.strip().split(',')
                if len(parts) < 4:
                    continue  # Skip lines that do not have enough data
                idd, x, y, demand = int(parts[0]), float(parts[1]), float(parts[2]), float(parts[3])
                node = Node(idd, x, y, demand)
                self.allNodes.append(node)
                if idd != 0:  # Assuming 0 is the ID for the depot
                    self.customers.append(node)

        # Calculate distance matrix
        rows = len(self.allNodes)
        self.matrix = [[0.0 for _ in range(rows)] for _ in range(rows)]
        for i in range(rows):
            for j in range(rows):
                a = self.allNodes[i]
                b = self.allNodes[j]
                dist = math.sqrt(math.pow(a.x - b.x, 2) + math.pow(a.y - b.y, 2))
                self.matrix[i][j] = dist

# Κώδικας για τις υπόλοιπες κλάσεις (Route, Solver κλπ) παραμένει ως έχει.


class Node:
    def __init__(self, idd, xx, yy, dem):
        self.x = xx
        self.y = yy
        self.ID = idd
        self.demand = dem
        self.isRouted = False


class Route:                                #ανοιχτη διαδρομη
    def __init__(self, dp, cap):
        self.sequenceOfNodes = []
        self.sequenceOfNodes.append(dp)
        self.cost = 0
        self.capacity = cap
        self.load = 0


filepath = r'D:\zaxariadhs\εργασία ζαχαριάδη\Instance.txt'

################################################################################################################
##################################################################################################################
###################################################################################################################

from VRP_Model import *

class Solution:
    def __init__(self):
        self.cost = 0.0
        self.routes = []
class Saving:
    def __init__(self, n1, n2, sav):
        self.n1 = n1
        self.n2 = n2
        self.score = sav
class Solver:
    def __init__(self, m):
        self.allNodes = m.allNodes
        self.customers = m.customers
        self.depot = m.allNodes[0]
        self.distanceMatrix = m.matrix
        self.capacity = m.capacity
        self.empty_vehicle_weight = m.empty_vehicle_weight  # Προσθήκη αυτής της γραμμής
        self.sol = None
        self.bestSolution = None

    def calculate_total_cost(self, sol, empty_vehicle_weight, distanceMatrix):
        total_cost = 0
        for route in sol.routes:
            route_cost = 0
            total_route_load = empty_vehicle_weight + sum(
                node.demand for node in route.sequenceOfNodes)  # Συνολικό βάρος στην αρχή της διαδρομής
            for i in range(len(route.sequenceOfNodes) - 1):
                from_node = route.sequenceOfNodes[i]
                to_node = route.sequenceOfNodes[i + 1]
                route_cost += distanceMatrix[from_node.ID][to_node.ID] * total_route_load
                total_route_load -= to_node.demand  # Μείωση του συνολικού βάρους μετά την παράδοση φορτίου
            total_cost += route_cost
        return total_cost

    def solve(self):
        self.SetRoutedFlagToFalseForAllCustomers()
        self.Clarke_n_Wright()
        self.apply_2_opt()  # Εφαρμογή του 2-opt local search μετά τον Clarke and Wright
        self.sol.cost = self.calculate_total_cost(self.sol, self.empty_vehicle_weight, self.distanceMatrix)
        self.ReportSolution(self.sol)
        return self.sol

    def apply_2_opt(self):
        improvement = True
        while improvement:  # Συνέχισε να επαναλαμβάνεις μέχρι να μην υπάρχουν περαιτέρω βελτιώσεις
            improvement = False  # Αρχικοποίησε τη βελτίωση σε False σε κάθε επανάληψη
            for route in self.sol.routes:  # Διάσχισε όλες τις διαδρομές στη λύση
                for i in range(1, len(route.sequenceOfNodes) - 2):  # Διάσχισε τους κόμβους της διαδρομής
                    for j in range(i + 2, len(route.sequenceOfNodes)):  # Διάσχισε τους επόμενους κόμβους για σύγκριση
                        if self.two_opt_swap(route, i, j):  # Εφάρμοσε την ανταλλαγή 2-opt στα σημεία i και j
                            improvement = True  # Αν υπάρχει βελτίωση, σημείωσε το και συνέχισε

    def two_opt_swap(self, route, i, j):
        new_route = route.sequenceOfNodes[:i] + route.sequenceOfNodes[i:j + 1][::-1] + route.sequenceOfNodes[j + 1:]
        new_cost = self.calculate_route_cost(route, new_route)
        if new_cost < route.cost:
            route.sequenceOfNodes = new_route
            route.cost = new_cost
            return True
        return False

    def SetRoutedFlagToFalseForAllCustomers(self):
        for i in range(0, len(self.customers)):
            self.customers[i].isRouted = False
        for c in self.customers:
            c.isRouted = False

    def ReportSolution(self, sol):
        output_file_path = "D:\\zaxariadhs\\εργασια ζαχαριάδη\\solution_output.txt"
        with open(output_file_path, "w") as file:
            # Εγγραφή του συνολικού κόστους
            file.write("Cost:\n{:.5f}\n".format(sol.cost))
            # Εγγραφή του αριθμού των διαδρομών
            file.write("Routes:\n{}\n".format(len(sol.routes)))
            # Εγγραφή κάθε διαδρομής
            for rt in sol.routes:
                route_str = "0," + ",".join(
                    str(node.ID) for node in rt.sequenceOfNodes[1:])  # Αγνοούμε το πρώτο στοιχείο αν είναι ο depot
                file.write(route_str + "\n")

    def UpdateRouteCostAndLoad(self, rt: Route):
        tc = 0
        tl = 0
        for i in range(0, len(rt.sequenceOfNodes) - 1):
            A = rt.sequenceOfNodes[i]
            B = rt.sequenceOfNodes[i + 1]
            tc += self.distanceMatrix[A.ID][B.ID]
            tl += A.demand
        rt.load = tl
        rt.cost = tc
#________________________________________________________________________________
    def calculate_route_cost(self, route, new_sequence_of_nodes):
        total_cost = 0
        for i in range(len(new_sequence_of_nodes) - 1):
            from_node = new_sequence_of_nodes[i]
            to_node = new_sequence_of_nodes[i + 1]
            total_cost += self.distanceMatrix[from_node.ID][to_node.ID]
        return total_cost

    def Clarke_n_Wright(self):
        self.sol = self.create_initial_routes()
        savings: list = self.calculate_savings()
        savings.sort(key=lambda s: s.score, reverse=True)
        for sav in savings:
            n1 = sav.n1
            n2 = sav.n2
            rt1 = n1.route
            rt2 = n2.route
            if rt1 == rt2 or self.not_first_or_last(rt1, n1) or self.not_first_or_last(rt2, n2) or rt1.load + rt2.load > self.capacity:
                continue
            self.merge_routes(n1, n2)
        # Ενημέρωση του συνολικού κόστους μετά την εφαρμογή του αλγορίθμου
        self.sol.cost = sum(self.calculate_route_cost(route, route.sequenceOfNodes) for route in self.sol.routes)

    def calculate_savings(self):
        savings = []
        for i in range(0, len(self.customers)):
            n1 = self.customers[i]
            for j in range(i + 1, len(self.customers)):
                n2 = self.customers[j]
                score = self.distanceMatrix[n1.ID][self.depot.ID] + self.distanceMatrix[self.depot.ID][n2.ID]
                score -= self.distanceMatrix[n1.ID][n2.ID]
                sav = Saving(n1, n2, score)
                savings.append(sav)
        return savings

    def create_initial_routes(self):
        s = Solution()
        for i in range(0, len(self.customers)):
            n = self.customers[i]
            if n.demand > self.capacity:  # Νέος έλεγχος
                raise Exception(f"Ο κόμβος με ID {n.ID} έχει απαίτηση φόρτωσης μεγαλύτερη από την χωρητικότητα")
            rt = Route(self.depot, self.capacity)
            n.route = rt
            n.position_in_route = 1
            rt.sequenceOfNodes.append(n)
            rt.load = n.demand
            rt.cost = self.distanceMatrix[self.depot.ID][n.ID]
            s.routes.append(rt)
            s.cost += rt.cost
        return s

    def not_first_or_last(self, rt, n):
        if n.position_in_route != 1 and n.position_in_route != len(rt.sequenceOfNodes) - 2:
            return True
        return False
#############################################
    def merge_routes(self, n1, n2):
        rt1 = n1.route
        rt2 = n2.route
        # Ensure different routes and capacity constraints
        if rt1 == rt2:
            return
        # Calculate the merged load
        merged_load = rt1.load + rt2.load
        if merged_load > 6.4:
            return  # Skip merging if it exceeds capacity
        # Merge rt2 into rt1
        rt1.sequenceOfNodes.extend(rt2.sequenceOfNodes[1:])  # Exclude the depot from rt2
        rt1.load = merged_load
        # Update the cost for the merged route
        self.UpdateRouteCostAndLoad(rt1)
        # Check if the updated route violates the capacity constraint
        if rt1.load > self.capacity:
            print(f"Παραβίαση χωρητικότητας: Η συνολική φόρτωση της διαδρομής {rt1} είναι {rt1.load}")
            # Undo the merge
            rt1.sequenceOfNodes = rt1.sequenceOfNodes[:len(rt1.sequenceOfNodes) - len(rt2.sequenceOfNodes[1:])]
            rt1.load -= rt2.load
            return
        # Remove rt2 from the solution
        if rt2 in self.sol.routes:
            self.sol.routes.remove(rt2)
        # Update route and position information for all customers in the merged route
        for i in range(1, len(rt1.sequenceOfNodes)):
            n = rt1.sequenceOfNodes[i]
            n.route = rt1
            n.position_in_route = i

######################################################################
    def update_route_customers(self, rt):
        for i in range (1, len(rt.sequenceOfNodes) - 1):
            n = rt.sequenceOfNodes[i]
            n.route = rt
            n.position_in_route = i

################################################################################################################
##################################################################################################################
###################################################################################################################

from Solver1 import *

m = Model()
filepath = 'D:\\zaxariadhs\\εργασια ζαχαριάδη\\Instance.txt'  # Ορίστε την ακριβή διαδρομή του αρχείου
m.BuildModel(filepath)
s = Solver(m)
sol = s.solve()


################################################################################################################
##################################################################################################################
###################################################################################################################

